/* Python 3 Grammar
 * 
 * The grammar is based on the file of following Github:
 *https://github.com/antlr/grammars-v4/blob/master/python3/Python3.g4
 * 
 * All comments that start with "///" are copy-pasted from
 * The Python Language Reference
 * 
 * https://docs.python.org/3/reference/index.html
 * 
 */

grammar python;


tokens { INDENT, DEDENT }

@lexer::members {
  // A queue where extra tokens are pushed on (see the NEWLINE lexer rule).
  private java.util.LinkedList<Token> tokens = new java.util.LinkedList<>();
  // The stack that keeps track of the indentation level.
  private java.util.Stack<Integer> indents = new java.util.Stack<>();
  // The amount of opened braces, brackets and parenthesis.
  private int opened = 0;
  // The most recently produced token.
  private Token lastToken = null;
  @Override
  public void emit(Token t) {
    super.setToken(t);
    tokens.offer(t);
  }

  @Override
  public Token nextToken() {
    // Check if the end-of-file is ahead and there are still some DEDENTS expected.
    if (_input.LA(1) == EOF && !this.indents.isEmpty()) {
      // Remove any trailing EOF tokens from our buffer.
      for (int i = tokens.size() - 1; i >= 0; i--) {
        if (tokens.get(i).getType() == EOF) {
          tokens.remove(i);
        }
      }

      // First emit an extra line break that serves as the end of the statement.
      this.emit(commonToken(pythonParser.NEWLINE, "\n"));

      // Now emit as much DEDENT tokens as needed.
      while (!indents.isEmpty()) {
        this.emit(createDedent());
        indents.pop();
      }

      // Put the EOF back on the token stream.
      this.emit(commonToken(pythonParser.EOF, "<EOF>"));
    }

    Token next = super.nextToken();

    if (next.getChannel() == Token.DEFAULT_CHANNEL) {
      // Keep track of the last token on the default channel.
      this.lastToken = next;
    }

    return tokens.isEmpty() ? next : tokens.poll();
  }

  private Token createDedent() {
    CommonToken dedent = commonToken(pythonParser.DEDENT, "");
    dedent.setLine(this.lastToken.getLine());
    return dedent;
  }

  private CommonToken commonToken(int type, String text) {
    int stop = this.getCharIndex() - 1;
    int start = text.isEmpty() ? stop : stop - text.length() + 1;
    return new CommonToken(this._tokenFactorySourcePair, type, DEFAULT_TOKEN_CHANNEL, start, stop);
  }

  // Calculates the indentation of the provided spaces, taking the
  // following rules into account:
  //
  // "Tabs are replaced (from left to right) by one to eight spaces
  //  such that the total number of characters up to and including
  //  the replacement is a multiple of eight [...]"
  //
  //  -- https://docs.python.org/3.1/reference/lexical_analysis.html#indentation
  static int getIndentationCount(String spaces) {
    int count = 0;
    for (char ch : spaces.toCharArray()) {
      switch (ch) {
        case '\t':
          count += 8 - (count % 8);
          break;
        default:
          // A normal space char.
          count++;
      }
    }

    return count;
  }

  boolean atStartOfInput() {
    return super.getCharPositionInLine() == 0 && super.getLine() == 1;
  }
}

/*
 * parser rules
 */

//INPUT
single_input: 
			NEWLINE 
			| simple_stmt 
			| compound_stmt NEWLINE
			;
			
file_input: 
			(NEWLINE | stmt)* EOF
			;
			
eval_input: 
			testlist NEWLINE* EOF
			; //??
testlist: test (',' test)* (',')?;

//STATEMENT
stmt: 
			simple_stmt 
			| compound_stmt
			;
			
//simple_stmt			
simple_stmt: small_stmt (';' small_stmt)* (';')? NEWLINE;

//small_stmt	
small_stmt: 
			(expr_stmt 
			| del_stmt 
			| pass_stmt 
			| flow_stmt 
			|import_stmt 
			| global_stmt 
			| nonlocal_stmt 
			| assert_stmt)
			;
			
//expression statement
expr_stmt: 
			testlist_star_expr (annassign 
								| augassign (yield_expr|testlist) 
								|('=' (yield_expr|testlist_star_expr))*)
			;					
annassign: ':' test ('=' test)?;
//test node, priority low to high
test: 
			or_test ('if' or_test 'else' test)? 
			| lambdef
			;
// not and or (logical operator)			
or_test: and_test ('or' and_test)*;
and_test: not_test ('and' not_test)*;
not_test: 
			'not' not_test 
			| comparison
			;
comparison: expr (comp_op expr)*;
//
comp_op: 	
			'<' //comparison operator
			|'>'
			|'=='
			|'>='
			|'<='
			|'<>'
			|'!='
			|'in' //membership operator
			|'not' 'in'
			|'is' //identity operator
			|'is' 'not'
			;
// | ^ (bitwise operator) 
expr: xor_expr ('|' xor_expr)*;
xor_expr: and_expr ('^' and_expr)*;
// & (bitwise AND)
and_expr: shift_expr ('&' shift_expr)*;
//shift operator
shift_expr: arith_expr (('<<'|'>>') arith_expr)*;
// + - (additive operator)
arith_expr: term (('+'|'-') term)*;
// * / % // (multiplicative operator)
term: factor (('*'|'@'|'/'|'%'|'//') factor)*;
// ~ +@ -@ ( bitwise NOT)
factor: ('+'|'-'|'~') factor | power;
// ** (exponentiation, with highest priority)
power: atom_expr ('**' factor)?;
atom_expr: (AWAIT)? atom trailer*;
atom: ('(' (yield_expr|testlist_comp)? ')' |
       '[' (testlist_comp)? ']' |
       '{' (dictorsetmaker)? '}' |
       NAME | NUMBER | STRING+ | '...' | 'None' | 'True' | 'False');
dictorsetmaker: ( ((test ':' test | '**' expr)
       (comp_for | (',' (test ':' test | '**' expr))* (',')?)) |
      ((test | star_expr)
       (comp_for | (',' (test | star_expr))* (',')?)) );
testlist_comp: (test|star_expr) ( comp_for | (',' (test|star_expr))* (',')? );
star_expr: '*' expr;
trailer: '(' (arglist)? ')' | '[' subscriptlist ']' | '.' NAME;
arglist: argument (',' argument)*  (',')?;
argument: ( test (comp_for)? |
            test '=' test |
            '**' test |
            '*' test );
comp_for: (ASYNC)? 'for' exprlist 'in' or_test (comp_iter)?;
comp_iter: comp_for | comp_if;
comp_if: 'if' test_nocond (comp_iter)?;
subscriptlist: subscript (',' subscript)* (',')?;
subscript: test | (test)? ':' (test)? (sliceop)?;
sliceop: ':' (test)?;

//lambda 
//Small anonymous functions can be created with the lambda keyword. 
lambdef: 'lambda' (varargslist)? ':' test;
varargslist: (vfpdef ('=' test)? (',' vfpdef ('=' test)?)* (',' (
        '*' (vfpdef)? (',' vfpdef ('=' test)?)* (',' ('**' vfpdef (',')?)?)?
      | '**' vfpdef (',')?)?)?
  | '*' (vfpdef)? (',' vfpdef ('=' test)?)* (',' ('**' vfpdef (',')?)?)?
  | '**' vfpdef (',')?
);
vfpdef: NAME;
			
testlist_star_expr: (test|star_expr) (',' (test|star_expr))* (',')?;			
augassign: 
			('+=' 
			| '-=' 
			| '*=' 
			| '@=' 
			| '/=' 
			| '%=' 
			| '&=' 
			| '|=' 
			| '^=' 
			|'<<=' 
			| '>>=' 
			| '**=' 
			| '//=')
			;
yield_expr: 'yield' (yield_arg)?;
yield_arg: 'from' test | testlist;


//delete statement 
///"del" target_list
del_stmt: 'del' exprlist;
exprlist: (expr|star_expr) (',' (expr|star_expr))* (',')?;

//pass statement
///pass is a null operation
pass_stmt: 'pass';

//flow statement
flow_stmt: 
			break_stmt 
			| continue_stmt 
			| return_stmt 
			| raise_stmt 
			| yield_stmt
			;
			
break_stmt: 'break';
continue_stmt: 'continue';
return_stmt: 'return' (testlist)?;
yield_stmt: yield_expr;
raise_stmt: 'raise' (test ('from' test)?)?;

//import statement
import_stmt: import_name | import_from;
import_name: 'import' dotted_as_names;
import_from: ('from' (('.' | '...')* dotted_name | ('.' | '...')+)
              'import' ('*' | '(' import_as_names ')' | import_as_names));
import_as_name: NAME ('as' NAME)?;
dotted_as_name: dotted_name ('as' NAME)?;
import_as_names: import_as_name (',' import_as_name)* (',')?;
dotted_as_names: dotted_as_name (',' dotted_as_name)*;
dotted_name: NAME ('.' NAME)*;

//global statement
///The global statement is a declaration which holds for the entire current code block. 
///It means that the listed identifiers are to be interpreted as globals. 
global_stmt: 'global' NAME (',' NAME)*;

//nonlocal statement
///The nonlocal statement causes the listed identifiers to 
///refer to previously bound variables in the nearest enclosing scope excluding globals. 
nonlocal_stmt: 'nonlocal' NAME (',' NAME)*;

//assert statement
///Assert statements are a convenient way to insert debugging assertions into a program
assert_stmt: 'assert' test (',' test)?;

//compound statement
compound_stmt: 
			if_stmt 
			| while_stmt 
			| for_stmt 
			| try_stmt 
			| with_stmt 
			| funcdef 
			| classdef 
			| decorated 
			| async_stmt
			;
			
//if
if_stmt: 'if' test ':' suite ('elif' test ':' suite)* ('else' ':' suite)?;
suite: simple_stmt | NEWLINE INDENT stmt+ DEDENT;

//while
while_stmt: 'while' test ':' suite ('else' ':' suite)?;

//for
for_stmt: 'for' exprlist 'in' testlist ':' suite ('else' ':' suite)?;

//try
try_stmt: ('try' ':' suite
           ((except_clause ':' suite)+
            ('else' ':' suite)?
            ('finally' ':' suite)? |
           'finally' ':' suite));
except_clause: 'except' (test ('as' NAME)?)?;
           
//with
with_stmt: 'with' with_item (',' with_item)*  ':' suite;
with_item: test ('as' expr)?;

//def
funcdef: 'def' NAME parameters ('->' test)? ':' suite;
parameters: '(' (typedargslist)? ')';
typedargslist: (tfpdef ('=' test)? (',' tfpdef ('=' test)?)* (',' (
        '*' (tfpdef)? (',' tfpdef ('=' test)?)* (',' ('**' tfpdef (',')?)?)?
      | '**' tfpdef (',')?)?)?
  | '*' (tfpdef)? (',' tfpdef ('=' test)?)* (',' ('**' tfpdef (',')?)?)?
  | '**' tfpdef (',')?);
tfpdef: NAME (':' test)?;

//class
classdef: 'class' NAME ('(' (arglist)? ')')? ':' suite;

//decorated
decorated: 
			decorators (classdef 
				| funcdef 
				| async_funcdef)
			;
			
decorators: decorator+;
decorator: '@' dotted_name ( '(' (arglist)? ')' )? NEWLINE;
async_funcdef: ASYNC funcdef;

//async
async_stmt: ASYNC (funcdef | with_stmt | for_stmt);

//
test_nocond: or_test | lambdef_nocond;
lambdef_nocond: 'lambda' (varargslist)? ':' test_nocond;

// not used in grammar, but may appear in "node" passed from Parser to Compiler
encoding_decl: NAME;

////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////

/*
 * lexer rules
 */

DEF : 'def';
RETURN : 'return';
IF : 'if';
ELIF : 'elif';
ELSE : 'else';
WHILE : 'while';
NOT : 'not';
TRUE : 'True';
FALSE : 'False';
CLASS : 'class';

ADD : '+';
MINUS : '-';
STAR : '*';
DIV : '/';

LESS_THAN : '<';
GREATER_THAN : '>';
EQUALS : '==';
NOT_EQ_2 : '!=';

ASSIGN : '=';

COMMA : ',';
COLON : ':';
SEMI_COLON : ';';

OPEN_PAREN : '(' {opened++;};
CLOSE_PAREN : ')' {opened--;};
OPEN_BRACK : '[' {opened++;};
CLOSE_BRACK : ']' {opened--;};
OPEN_BRACE : '{' {opened++;};
CLOSE_BRACE : '}' {opened--;};


SKIP_
 : ( SPACES | COMMENT | LINE_JOINING ) -> skip
 ;
 
 NAME
 : ID_START ID_CONTINUE*
 ;
 
 NUMBER
 : NON_ZERO_DIGIT DIGIT*
 | '0'+
 ;
 
 fragment SPACES
 : [ \t]+
 ;

fragment COMMENT
 : '#' ~[\r\n\f]*
 ;

fragment LINE_JOINING
 : '\\' SPACES? ( '\r'? '\n' | '\r' | '\f')
 ;

fragment ID_START
 : '_'
 | [A-Z]
 | [a-z]
 ;

fragment ID_CONTINUE
 : ID_START 
 | [0-9]
;

fragment NON_ZERO_DIGIT
 : [1-9]
 ;
 
fragment DIGIT
 : [0-9]
 ;
////////////////////////////////////////////////////////////////////////

STRING
 : STRING_LITERAL
 ;



NEWLINE
 : ( {atStartOfInput()}?   SPACES
   | ( '\r'? '\n' | '\r' | '\f' ) SPACES?
   )
   {
     String newLine = getText().replaceAll("[^\r\n\f]+", "");
     String spaces = getText().replaceAll("[\r\n\f]+", "");
     int next = _input.LA(1);
     if (opened > 0 || next == '\r' || next == '\n' || next == '\f' || next == '#') {
       // If we're inside a list or on a blank line, ignore all indents, 
       // dedents and line breaks.
       skip();
     }
     else {
       emit(commonToken(NEWLINE, newLine));
       int indent = getIndentationCount(spaces);
       int previous = indents.isEmpty() ? 0 : indents.peek();
       if (indent == previous) {
         // skip indents of the same size as the present indent-size
         skip();
       }
       else if (indent > previous) {
         indents.push(indent);
         emit(commonToken(pythonParser.INDENT, spaces));
       }
       else {
         // Possibly emit more than 1 DEDENT token.
         while(!indents.isEmpty() && indents.peek() > indent) {
           this.emit(createDedent());
           indents.pop();
         }
       }
     }
   }
 ;



/// stringliteral   ::=  [stringprefix](shortstring | longstring)
/// stringprefix    ::=  "r" | "u" | "R" | "U" | "f" | "F"
///                      | "fr" | "Fr" | "fR" | "FR" | "rf" | "rF" | "Rf" | "RF"
STRING_LITERAL
 : ( [rR] | [uU] | [fF] | ( [fF] [rR] ) | ( [rR] [fF] ) )? ( SHORT_STRING | LONG_STRING )
 ;


/// decimalinteger ::=  nonzerodigit digit* | "0"+



UNKNOWN_CHAR
 : .
 ;

/* 
 * fragments 
 */

/// shortstring     ::=  "'" shortstringitem* "'" | '"' shortstringitem* '"'
/// shortstringitem ::=  shortstringchar | stringescapeseq
/// shortstringchar ::=  <any source character except "\" or newline or the quote>
fragment SHORT_STRING
 : '\'' ( STRING_ESCAPE_SEQ | ~[\\\r\n\f'] )* '\''
 | '"' ( STRING_ESCAPE_SEQ | ~[\\\r\n\f"] )* '"'
 ;
/// longstring      ::=  "'''" longstringitem* "'''" | '"""' longstringitem* '"""'
fragment LONG_STRING
 : '\'\'\'' LONG_STRING_ITEM*? '\'\'\''
 | '"""' LONG_STRING_ITEM*? '"""'
 ;

/// longstringitem  ::=  longstringchar | stringescapeseq
fragment LONG_STRING_ITEM
 : LONG_STRING_CHAR
 | STRING_ESCAPE_SEQ
 ;

/// longstringchar  ::=  <any source character except "\">
fragment LONG_STRING_CHAR
 : ~'\\'
 ;

/// stringescapeseq ::=  "\" <any source character>
fragment STRING_ESCAPE_SEQ
 : '\\' .
 | '\\' NEWLINE
 ;


/// intpart       ::=  digit+
fragment INT_PART
 : DIGIT+
 ;

/// fraction      ::=  "." digit+
fragment FRACTION
 : '.' DIGIT+
 ;



