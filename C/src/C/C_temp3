/*
 C 2011 grammar built from the C11 Spec 
 * 
 * The grammar is based on the file of following Github:
 * https://github.com/antlr/grammars-v4/blob/master/c/C.g4
 * 
 * All comments that start with "///" are copy-pasted from
 * The C Language Reference
 * 
 */
	
grammar C;

// Parser rules

//Declaration
declaration
    :   ('void' | 'char' | 'int' | '_Bool')+ initDeclaratorList ';' 
	| 	('void' | 'char' | 'int' | '_Bool')+ ';' 
	;

initDeclaratorList
    :   initDeclarator
    |   initDeclaratorList ',' initDeclarator
    ;

initDeclarator
    :   directDeclarator
    |   directDeclarator '=' initializer
    ;
    
initializer
    :   assignmentExpression;
//    |   '{' initializerList '}'
//    |   '{' initializerList ',' '}'
//    ;
//
//initializerList
//    :   initializer
//    |   initializerList ',' initializer
//    ;
    
directDeclarator
    :   Identifier
    |   '(' directDeclarator ')'
    |   directDeclarator '(' parameterList ')'
    |   directDeclarator '(' identifierList? ')'
    ;    

identifierList
    :   Identifier
    |   identifierList ',' Identifier
    ;

parameterList
    :   ('void' | 'char' | 'int' | '_Bool')+ directDeclarator
    |   parameterList ',' ('void' | 'char' | 'int' | '_Bool')+ directDeclarator
    ;
   
//Expression	

primaryExpression
    :   Identifier
    |   '(' expression ')'
    ;
    
expression
    :   assignmentExpression
    |   expression ',' assignmentExpression
    ;
    
assignmentExpression
    :   conditionalExpression
    |   unaryExpression Assign assignmentExpression
    ;
    
conditionalExpression
    :   relationalExpression
    |   conditionalExpression '==' relationalExpression
    |   conditionalExpression '!=' relationalExpression
    ;

relationalExpression
    :   additiveExpression
    |   relationalExpression '<' additiveExpression
    |   relationalExpression '>' additiveExpression
    ;

additiveExpression
    :   multiplicativeExpression
    |   additiveExpression '+' multiplicativeExpression
    |   additiveExpression '-' multiplicativeExpression
    ;
    
multiplicativeExpression
    :   castExpression
    |   multiplicativeExpression '*' castExpression
    |   multiplicativeExpression '/' castExpression
    ;
    
castExpression
    :   '(' typeName ')' castExpression
    |   unaryExpression
    ;
    
unaryExpression
    :   '++' unaryExpression
    |   '--' unaryExpression
    |   unaryOperator castExpression
    |   'sizeof' unaryExpression
    |   'sizeof' '(' typeName ')'
    ;

unaryOperator
    :   '&' | '*' | '+' | '-' | '~' | '!'
    ;
    
typeName
    :   ('void' | 'char' | 'int' | '_Bool') typeName?
    ;
    
argumentExpressionList
    :   assignmentExpression
    |   argumentExpressionList ',' assignmentExpression
    ;

//Statement

statement
    :   compoundStatement
    |   expression? ';'
    |   'if' '(' expression ')' statement ('else' statement)?		
    |   While '(' expression ')' statement      
    ;
    
compoundStatement
    :   '{' blockItemList? '}'
    ;

blockItemList
    :   (statement | declaration)
    |   blockItemList (statement | declaration)
    ;
    

// Lexicon
Char : 'char';
Else : 'else';
If : 'if';
Int : 'int';
Return : 'return';
While : 'while';

Equal : '==';
Less : '<';
Greater : '>';
Plus : '+';
Minus : '-';
Star : '*';
Div : '/';

Assign : '=';

LeftParen : '(';
RightParen : ')';
LeftBrace : '{';
RightBrace : '}';
Colon : ':';
Semi : ';';

Identifier
    :   Nondigit
        (   Nondigit
        |   Digit
        )*
    ;

fragment
Nondigit
    :   [a-zA-Z_]
    ;

fragment
Digit
    :   [0-9]
    ;
    Whitespace
    :   [ \t]+
        -> skip
    ;

Newline
    :   (   '\r' '\n'?
        |   '\n'
        )
        -> skip
    ;

BlockComment
    :   '/*' .*? '*/'
        -> skip
    ;

LineComment
    :   '//' ~[\r\n]*
        -> skip
;